% % \section{Revisão Bibliográfica}

% % O problema da mochila 0-1 pode ser modelado como um problema de programação inteira binária:

% % \begin{equation*}
% % \begin{aligned}
% % \text{Maximize:} &\quad \sum_{i=1}^n v_i x_i \\
% % \text{Sujeito a:} &\quad \sum_{i=1}^n w_i x_i \le W \\
% % \text{Com:} &\quad x_i \in \{0,1\}, \quad i = 1, \dots, n
% % \end{aligned}
% % \end{equation*}

% % A versão de decisão do problema é NP-completa, enquanto a versão de otimização é NP-difícil no sentido fraco. Isso significa que existem algoritmos de tempo pseudo-polinomial, como a programação dinâmica com complexidade $O(nW)$, que são eficientes para instâncias pequenas ou médias.

% % Além disso, existem algoritmos exatos baseados em \textit{branch-and-bound}, relaxações lineares e o algoritmo \textit{meet-in-the-middle} de Horowitz e Sahni (1974), que exploram características do problema para reduzir o espaço de busca.

% % Do ponto de vista da aproximação, o problema admite esquemas FPTAS (Fully Polynomial-Time Approximation Schemes), como os desenvolvidos por Ibarra e Kim (1975), que garantem soluções com fator de aproximação arbitrário em tempo polinomial.

% % Entre as variantes importantes do problema estão:

% % \begin{itemize}
% %     \item \textbf{Mochila limitada}: múltiplas cópias de cada item ($x_i \le c_i$);
% %     \item \textbf{Mochila ilimitada}: número ilimitado de cópias ($x_i \in \mathbb{N}$);
% %     \item \textbf{Mochila multidimensional}: múltiplas restrições (peso, volume, etc.);
% %     \item \textbf{Subset Sum}: caso especial em que $v_i = w_i$, também NP-completo.
% % \end{itemize}

% % Diversas heurísticas também são aplicadas ao problema, como algoritmos genéticos, colônia de formigas e busca por enxame de partículas, principalmente em variantes de grande escala. Tais abordagens são úteis quando não se exige solução ótima, mas sim boa qualidade em tempo aceitável.


% \section{Revisão Bibliográfica}

% O problema da mochila 0-1 pode ser formalizado como um problema de programação inteira binária. Dado um conjunto de $n$ itens numerados de $1$ a $n$, cada um com peso $w_i$ e valor $v_i$, e dado um limite de capacidade $W$, busca-se uma atribuição binária $x_i \in \{0,1\}$ (incluir ou não o item $i$) que maximiza o valor total:

% \[
% \text{Objetivo: } \max \sum_{i=1}^n v_i x_i
% \]

% Sujeito à restrição:

% \[
% \sum_{i=1}^n w_i x_i \le W
% \]

% Onde o domínio de cada variável é dado por $x_i \in \{0,1\}$ para $i = 1, \dots, n$. 

% Essa formulação reflete exatamente o desafio de maximizar o valor dos itens carregados enquanto não se excede a capacidade de peso da mochila. Em palavras, escolhe-se um subconjunto de itens cujo peso total não ultrapasse $W$ e cujo valor total seja o maior possível.

% Quanto à complexidade computacional, o problema é intrinsecamente difícil. A versão de decisão (“existe subconjunto com valor pelo menos $V$ sem exceder $W$?”) é NP-completa. Consequentemente, o problema de otimização é NP-difícil no sentido geral. Na verdade, o problema da mochila 0-1 é classificado como NP-difícil fraco (“weakly NP-hard”), pois admite um algoritmo de programação dinâmica de tempo pseudo-polinomial~\cite{pisinger2005}. 

% Isso ocorre porque o tempo de execução do algoritmo dinâmico típico é proporcional a $nW$, o que é polinomial em $n$, mas exponencial no tamanho da representação de $W$ (que tem $\log W$ bits). De forma ilustrativa, supondo que $W$ dobre, o tempo de um algoritmo $O(nW)$ também dobra, mas o tamanho da entrada (em bits) só cresce linearmente em $\log W$, evidenciando que $O(nW) = O(n2^{\log W})$ é exponencial no tamanho da entrada. Por isso, diz-se que uma solução em tempo $O(nW)$ não contradiz a NP-dificuldade do problema.

% No entanto, apesar de ser NP-difícil, o problema da mochila 0-1 possui diversas abordagens de solução. O método exato mais conhecido é a programação dinâmica, onde constrói-se uma tabela de subproblemas considerando os primeiros $i$ itens e capacidades até $W$, resultando em complexidade $O(nW)$. Existem também algoritmos exatos baseados em branch-and-bound ou em técnicas avançadas que usam limites obtidos pela relaxação linear do problema (solucionável por algoritmo ganancioso, no caso da mochila fracionária) para podar ramos da árvore de busca. Por exemplo, Pisinger~\cite{pisinger2005} cita heurísticas eficientes que partem de uma solução fracionária otimizada e a ajustam para a solução inteira através de branch-and-bound.

% Outro algoritmo exato clássico é o de meet-in-the-middle de Horowitz e Sahni~\cite{horowitz1974}, que tem complexidade exponencial em $n$, mas, sob certas condições, pode superar a programação dinâmica quando $n$ é grande e $W$ moderado. De modo geral, porém, não existe algoritmo exato de tempo polinomial garantido para todos os casos de entrada.

% Como compensação para a ausência de solução polinomial geral, existem esquemas de aproximação que fornecem soluções próximas do ótimo. Notavelmente, o problema da mochila 0-1 admite FPTAS (Fully Polynomial-Time Approximation Schemes), que garantem um fator de aproximação $1+\varepsilon$ em tempo polinomial em $n$ e em $1/\varepsilon$~\cite{jin2019}. Em termos práticos, isso significa que podemos obter soluções arbitrariamente próximas do ótimo em tempo razoável, ajustando um parâmetro de precisão. Essas técnicas baseiam-se em versões escalonadas dos valores ou pesos, inspiradas nos algoritmos de Ibarra \& Kim~\cite{ibarra1975}.

% Além disso, há heurísticas e meta-heurísticas (como algoritmos genéticos, colônia de formigas, enxame de partículas, etc.) aplicadas ao problema, especialmente em variantes de grande escala. Contudo, tais heurísticas não têm garantias polinomiais formais.

% O problema da mochila 0-1 possui variações que ampliam ou alteram suas restrições para contextos distintos. Na mochila limitada (bounded knapsack), supõe-se que existem múltiplas cópias limitadas de cada item: cada variável $x_i$ pode assumir valores inteiros até um limite superior $c_i$ (por exemplo, $x_i \in \{0,1,2,\dots,c_i\}$). Na mochila ilimitada (unbounded knapsack), o número de cópias não tem teto, ou seja, $x_i \in \mathbb{N}$ sem limite, o que permite usar itens repetidamente até encher a capacidade. Há também a mochila multi-dimensão (vários recursos simultâneos, e.g., peso e volume) e a mochila múltipla/escolha múltipla, em que itens são agrupados em classes e escolhe-se ao máximo uma unidade de cada classe. A literatura especializada trata ainda a mochila quadrática e outras extensões avançadas.

% Uma variação fundamental é o problema da soma de subconjuntos (subset sum), em que assume-se $v_i = w_i$ para todos os itens; esse caso especial é exatamente NP-completo (foi um dos 21 problemas NP-completos clássicos listados por Karp). Em suma, essas variantes ilustram a riqueza de configurações do problema e sua importância em modelar diferentes cenários práticos.

\section{Revisão Bibliográfica}

O problema da mochila 0-1 pode ser formalizado como um problema de programação inteira binária. Dado um conjunto de $n$ itens numerados de $1$ a $n$, cada um com peso $w_i$ e valor $v_i$, e dado um limite de capacidade $W$, busca-se uma atribuição binária $x_i \in \{0,1\}$ (incluir ou não o item $i$) que maximize o valor total:

\begin{align*}
\text{Objetivo:} &\quad \max \sum_{i=1}^n v_i x_i \\
\text{Restrição:} &\quad \sum_{i=1}^n w_i x_i \le W \\
\text{Domínio:} &\quad x_i \in \{0,1\},\quad i=1,\dots,n
\end{align*}

Essa formulação reflete exatamente o desafio de maximizar o valor dos itens carregados sem exceder a capacidade da mochila. Em termos práticos, escolhe-se um subconjunto de itens cujo peso total não ultrapasse $W$ e cujo valor total seja o maior possível.

Quanto à complexidade computacional, o problema é intrinsecamente difícil. A versão de decisão (``existe subconjunto com valor pelo menos $V$ sem exceder $W$?'') é \textit{NP-completa}, e a versão de otimização é \textit{NP-difícil}. Mais especificamente, o problema da mochila 0-1 é \textit{fraco NP-difícil} (weakly NP-hard), pois admite algoritmos pseudo-polinomiais, como o de programação dinâmica com tempo $O(nW)$ \cite{pisinger2005}.

Esse tempo de execução é considerado pseudo-polinomial porque depende linearmente de $n$ e de $W$, mas exponencialmente do tamanho da entrada binária (já que $W$ pode ter $\log W$ bits). Por exemplo, dobrar o valor de $W$ dobra o tempo do algoritmo, mas o tamanho da entrada cresce apenas linearmente em $\log W$. Assim, $O(nW) = O(n2^{\log W})$ é exponencial no tamanho da entrada, o que mantém a consistência com a complexidade \textit{NP-difícil}.

Apesar disso, diversas abordagens exatas foram desenvolvidas. A mais clássica é a própria programação dinâmica. Outras envolvem técnicas como \textit{branch-and-bound}, onde limites obtidos por relaxação linear (como no problema da mochila fracionária) são usados para podar ramos de busca \cite{martello1990}. Heurísticas que partem de soluções fracionárias e as ajustam para soluções inteiras também têm sido efetivas \cite{pisinger2005}.

Outro algoritmo exato relevante é o \textit{meet-in-the-middle}, proposto por Horowitz e Sahni \cite{horowitz1974}, que, embora tenha complexidade exponencial em $n$, pode ser mais eficiente que a programação dinâmica quando $n$ é grande e $W$ é moderado.

Como alternativa à ausência de algoritmos exatos de tempo polinomial, foram propostos esquemas de aproximação. Em particular, o problema admite esquemas \textit{FPTAS} (Fully Polynomial-Time Approximation Schemes), que garantem aproximações com fator $1 + \varepsilon$ em tempo polinomial em $n$ e $1/\varepsilon$ \cite{ibarra1975,jin2019}.

Esses algoritmos baseiam-se na discretização dos valores ou pesos, e são capazes de produzir soluções arbitrariamente próximas do ótimo em tempo viável. Além disso, heurísticas metaheurísticas como algoritmos genéticos, colônia de formigas e enxame de partículas também são aplicadas em versões de larga escala, embora sem garantias formais de aproximação.

O problema possui ainda diversas variantes que ampliam sua complexidade e aplicabilidade:
\begin{itemize}
    \item \textbf{Mochila limitada} (bounded knapsack): permite múltiplas cópias limitadas de cada item ($x_i \in \{0, 1, \dots, c_i\}$);
    \item \textbf{Mochila ilimitada} (unbounded knapsack): número ilimitado de cópias de cada item ($x_i \in \mathbb{N}$);
    \item \textbf{Mochila multidimensional}: considera múltiplas restrições (como peso e volume);
    \item \textbf{Mochila múltipla ou de escolha múltipla}: os itens são agrupados em classes, sendo permitido escolher um item por classe;
    \item \textbf{Mochila quadrática e outras extensões}: envolvem funções objetivo não lineares;
    \item \textbf{Subset Sum}: caso especial onde $v_i = w_i$ para todos os itens, sendo exatamente \textit{NP-completo}, como listado por Karp \cite{karp1972}.
\end{itemize}

Essas variantes mostram a flexibilidade do problema da mochila como modelo para cenários reais e seu papel central na teoria da complexidade e otimização combinatória.
